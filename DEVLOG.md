# Журнал разработки

## Этап 0. Подготовка (планирование)

**Что сделано:**
- Формализованы требования из исходного задания
- Проведён анализ: выявлен неявный POST-эндпоинт, определены архитектурные решения
- Составлен чеклист реализации
- Определена методология: AI-ассистированная разработка с акцентом на управление процессом
- Создан `.gitignore`, инициализирован репозиторий

**Решения на этом этапе:**
- Модульная структура (config / models / routes / app)
- Чистый `sqlite3` без ORM
- Seed-данные при первом запуске
- Docker + volume для персистентности

**Проблемы / корректировки:**
- Исходное решение: фронтенд через Jinja2 (`render_template`). Скорректировано:
  фронтенд — самостоятельная HTML-страница в `static/`, без зависимости от шаблонизатора.
  Причина: задание явно разделяет бэкенд (задание 1) и фронтенд (задание 2),
  интеграция происходит только в задании 3.
- Чеклист перестроен: вместо группировки по типу (бэкенд/фронтенд/Docker)
  выстроен последовательно по заданиям (1 → 2 → 3).
- Docker-конфиги перенесены из отдельного раздела в «Подготовку (инфраструктура)».

---

## Этап 1. Инфраструктура

**Что сделано:**
- Созданы каталоги: `app/`, `static/js/`, `data/`
- `requirements.txt`: Flask 3.1.0 (sqlite3 — встроенный модуль, не требует установки)
- `Dockerfile`: образ `python:3.12-slim`, установка зависимостей, запуск `run.py`
- `docker-compose.yml`: сервис `web`, порт 5000, volume `./data:/app/data`, `restart: unless-stopped`

**Что скорректировано после ревью:**
- (нет)

**Проблемы / корректировки:**
- (нет)

---

## Этап 2. Задание 1 — Бэкенд

**Что сделано:**
- `app/config.py` — конфигурация: пути к БД и каталогу данных, настройки Flask (host, port, debug, secret_key) через переменные окружения
- `app/models.py` — слой данных:
  - `get_connection()` — подключение к SQLite с `row_factory = sqlite3.Row`
  - `init_db()` — создание таблицы `users`, автоматический вызов `seed_db` при пустой таблице
  - `seed_db()` — 5 тестовых пользователей
  - `get_all_users()`, `get_user_by_id()` — чтение данных
- `app/routes.py` — Blueprint `api`:
  - `GET /users` — список пользователей (JSON)
  - `GET /users/<id>` — пользователь по id (JSON), 404 если не найден
- `app/__init__.py` — фабрика `create_app()`: создание Flask-app, указание `static_folder`, регистрация Blueprint, вызов `init_db()`
- `run.py` — точка входа: вызов `create_app()`, запуск сервера
- `.env.example` — документация переменных окружения

**Что скорректировано после ревью:**
- Точка входа перенесена из `app/app.py` в `run.py` (корень проекта) —
  circular import при `from app import create_app` внутри пакета `app/`

**Проблемы / корректировки:**
- Circular import при первом запуске в Docker. Причина: `app/app.py` находился
  внутри пакета `app/`, Python при `from app import create_app` пытался
  инициализировать пакет, который ещё загружался. Исправлено переносом в `run.py`.

**Результаты проверки:**
- `GET /users` — 200, JSON с 5 seed-пользователями
- `GET /users/1` — 200, JSON с конкретным пользователем
- `GET /users/999` — 404, `{"error": "Пользователь не найден"}`

---

## Этап 3. Задание 2 — Фронтенд

**Что сделано:**
- `static/index.html` — HTML-страница: Bootstrap 5 CDN, таблица пользователей,
  модальное окно с деталями (dl/dd-разметка)
- `static/js/app.js` — клиентская логика: `loadUsers()`, `renderTable()`,
  `showUserDetail()` с Fetch API, модалка через `bootstrap.Modal`

**Что скорректировано после ревью:**
- Архитектура переработана: Flask перестал раздавать статику.
  Добавлен nginx как отдельный сервис (`frontend`).
  Причина: фронтенд должен быть независим от бэкенда (по заданию — отдельная страница).
- `docker-compose.yml` — два сервиса: `api` (Flask) и `frontend` (nginx:alpine)
- `nginx/nginx.conf` — раздача статики из `static/`, проксирование `/users` → `api:5000`
- `app/__init__.py` — `static_folder=None`, Flask больше не раздаёт файлы
- `app/routes.py` — убран маршрут `GET /`
- `static/index.html` — путь к JS изменён с `/static/js/app.js` на `/js/app.js`
- Статические файлы монтируются как volume — изменения без пересборки контейнера

**Проблемы / корректировки:**
- (нет)

**Результаты проверки:**
- Страница загружается на `http://localhost:5000/`
- Таблица отображает 5 seed-пользователей
- Клик по строке открывает модальное окно с деталями
- Два контейнера работают (api + frontend)
- Изменения в `static/` подхватываются без пересборки

---

## Этап 4. Задание 3 — Интеграция

**Что сделано:**
- `app/models.py` — добавлена `create_user(name, email)`, возвращает созданного пользователя
- `app/routes.py` — `POST /users`: парсинг JSON, валидация (имя, email, формат email),
  возврат 201 при успехе, 400 при ошибке
- `static/index.html` — форма добавления (карточка над таблицей), контейнер для алертов
- `static/js/app.js` — `handleAddUser()`: POST через Fetch API, `showAlert()`:
  Bootstrap-алерты с автоскрытием через 5 сек, обновление таблицы без перезагрузки

**Что скорректировано после ревью:**
- (нет)

**Проблемы / корректировки:**
- (нет)

**Результаты проверки:**
- Пустое тело → 400 «Тело запроса должно быть JSON»
- Пустое имя → 400 «Имя обязательно»
- Некорректный email → 400 «Некорректный формат email»
- Успешное создание → 201, пользователь в ответе и в таблице
- HTML-валидация (`required`) не пускает пустую форму на клиенте
- Зелёное уведомление при успехе, автоскрытие через 5 сек
- Таблица обновляется без перезагрузки страницы

---

## Этап 5. Документация

**Что сделано:**
- `README.md` дополнен разделом «Запуск»: требования, команды, описание процесса,
  таблица API-эндпоинтов, управление данными (сброс БД)

**Что скорректировано после ревью:**
- Убрано разделение Docker Engine / Docker Desktop — несущественно для пользователя
- Команды приведены к современному синтаксису `docker compose` (без дефиса)
- Требования упрощены до «Docker с поддержкой Compose»

**Проблемы / корректировки:**
- (нет)

---

## Этап 6. Финальная проверка

**Что сделано:**
- Полный прогон с нуля: удаление БД, пересборка контейнеров
- Проверка всех API-эндпоинтов (GET /users, GET /users/1, GET /users/999, POST /users, POST с невалидными данными)
- Проверка персистентности: перезапуск контейнеров, данные на месте
- Проверка UI: таблица, модалка, форма, уведомления
- Все пункты CHECKLIST.md отмечены как выполненные

**Что скорректировано после ревью:**
- (нет)

**Проблемы / корректировки:**
- (нет)

---

## Этап 7. Планирование тестов

**Что сделано:**
- Определены уровни тестирования: unit (models.py), интеграционные (API), фронтенд (lint/unit/E2E)
- Выбраны инструменты: pytest, pytest-cov, Flask test_client, фикстуры с `:memory:` SQLite
- Составлен чеклист тестов: `CHECKLIST-TESTS.md`
- E2E-тесты решено не реализовывать (overkill для учебного проекта)
- Тесты проектируются CI-ready: одна команда запуска, exit code, отчёт покрытия
- CI-конфиг и badge покрытия — запланированы как отдельный этап

**Почему тесты добавляются после реализации, а не параллельно (TDD):**
- Исходное задание не предполагало тестов — проект учебный, логика минимальна
- Решение добавить тесты возникло при планировании CI/CD — пайплайну нужен
  автоматизированный этап проверки, тесты становятся необходимой инфраструктурой
- Для зрелого проекта это типичная ситуация: тесты дописываются
  к работающему коду при переходе от ручной проверки к автоматизированной

**Решения на этом этапе:**
- `pytest` вместо `unittest` — лаконичнее, стандарт де-факто
- Временная БД в памяти (`:memory:`) — быстро, изолированно, без файлов
- Отдельный `requirements-test.txt` — тестовые зависимости не попадают в production-образ
- Фронтенд-тестирование: ESLint обязательно, Jest опционально

**Проблемы / корректировки:**
- (нет)

---

## Этап 8. Unit-тесты models.py

**Что сделано:**
- `requirements-test.txt` — pytest 9.0.2, pytest-cov 6.1.1, ссылка на requirements.txt
- `tests/__init__.py`, `tests/conftest.py` — фикстура `_tmp_db` (autouse):
  подменяет `DATA_DIR` и `DATABASE` через monkeypatch на `tmp_path`,
  каждый тест получает чистую БД
- `tests/test_models.py` — 13 тестов по 6 классам:
  `TestGetConnection` (2), `TestInitDb` (3), `TestSeedDb` (1),
  `TestGetAllUsers` (3), `TestGetUserById` (2), `TestCreateUser` (2)
- `Dockerfile` — multi-stage build: стадия `base` (production) и `test` (+ pytest)
- `docker-compose.yml` — сервис `test` с профилем `test`, `target: test`;
  сервис `api` явно указывает `target: base`
- Запуск: `docker compose run --rm test`
- `README.md` — раздел «Тесты», обновлена структура проекта и таблица инструментов

**Результаты проверки:**
- 13/13 тестов passed
- Покрытие: `models.py` — 100%, `config.py` — 100%, общее — 69%
- Продакшен-сборка (`docker compose build api`) не затронута

**Что скорректировано после ревью:**
- (нет)

**Проблемы / корректировки:**
- (нет)

---

<!-- Шаблон для следующих этапов:

## Этап N. <Название>

**Что сделано:**
- ...

**Что скорректировано после ревью:**
- ...

**Проблемы / корректировки:**
- ...

-->
