# Журнал разработки

## Этап 0. Подготовка (планирование)

**Что сделано:**
- Формализованы требования из исходного задания
- Проведён анализ: выявлен неявный POST-эндпоинт, определены архитектурные решения
- Составлен чеклист реализации
- Определена методология: AI-ассистированная разработка с акцентом на управление процессом
- Создан `.gitignore`, инициализирован репозиторий

**Решения на этом этапе:**
- Модульная структура (config / models / routes / app)
- Чистый `sqlite3` без ORM
- Seed-данные при первом запуске
- Docker + volume для персистентности

**Проблемы / корректировки:**
- Исходное решение: фронтенд через Jinja2 (`render_template`). Скорректировано:
  фронтенд — самостоятельная HTML-страница в `static/`, без зависимости от шаблонизатора.
  Причина: задание явно разделяет бэкенд (задание 1) и фронтенд (задание 2),
  интеграция происходит только в задании 3.
- Чеклист перестроен: вместо группировки по типу (бэкенд/фронтенд/Docker)
  выстроен последовательно по заданиям (1 → 2 → 3).
- Docker-конфиги перенесены из отдельного раздела в «Подготовку (инфраструктура)».

---

## Этап 1. Инфраструктура

**Что сделано:**
- Созданы каталоги: `app/`, `static/js/`, `data/`
- `requirements.txt`: Flask 3.1.0 (sqlite3 — встроенный модуль, не требует установки)
- `Dockerfile`: образ `python:3.12-slim`, установка зависимостей, запуск `run.py`
- `docker-compose.yml`: сервис `web`, порт 5000, volume `./data:/app/data`, `restart: unless-stopped`

**Что скорректировано после ревью:**
- (нет)

**Проблемы / корректировки:**
- (нет)

---

## Этап 2. Задание 1 — Бэкенд

**Что сделано:**
- `app/config.py` — конфигурация: пути к БД и каталогу данных, настройки Flask (host, port, debug, secret_key) через переменные окружения
- `app/models.py` — слой данных:
  - `get_connection()` — подключение к SQLite с `row_factory = sqlite3.Row`
  - `init_db()` — создание таблицы `users`, автоматический вызов `seed_db` при пустой таблице
  - `seed_db()` — 5 тестовых пользователей
  - `get_all_users()`, `get_user_by_id()` — чтение данных
- `app/routes.py` — Blueprint `api`:
  - `GET /users` — список пользователей (JSON)
  - `GET /users/<id>` — пользователь по id (JSON), 404 если не найден
- `app/__init__.py` — фабрика `create_app()`: создание Flask-app, указание `static_folder`, регистрация Blueprint, вызов `init_db()`
- `run.py` — точка входа: вызов `create_app()`, запуск сервера
- `.env.example` — документация переменных окружения

**Что скорректировано после ревью:**
- Точка входа перенесена из `app/app.py` в `run.py` (корень проекта) —
  circular import при `from app import create_app` внутри пакета `app/`

**Проблемы / корректировки:**
- Circular import при первом запуске в Docker. Причина: `app/app.py` находился
  внутри пакета `app/`, Python при `from app import create_app` пытался
  инициализировать пакет, который ещё загружался. Исправлено переносом в `run.py`.

**Результаты проверки:**
- `GET /users` — 200, JSON с 5 seed-пользователями
- `GET /users/1` — 200, JSON с конкретным пользователем
- `GET /users/999` — 404, `{"error": "Пользователь не найден"}`

---

## Этап 3. Задание 2 — Фронтенд

**Что сделано:**
- `static/index.html` — HTML-страница: Bootstrap 5 CDN, таблица пользователей,
  модальное окно с деталями (dl/dd-разметка)
- `static/js/app.js` — клиентская логика: `loadUsers()`, `renderTable()`,
  `showUserDetail()` с Fetch API, модалка через `bootstrap.Modal`

**Что скорректировано после ревью:**
- Архитектура переработана: Flask перестал раздавать статику.
  Добавлен nginx как отдельный сервис (`frontend`).
  Причина: фронтенд должен быть независим от бэкенда (по заданию — отдельная страница).
- `docker-compose.yml` — два сервиса: `api` (Flask) и `frontend` (nginx:alpine)
- `nginx/nginx.conf` — раздача статики из `static/`, проксирование `/users` → `api:5000`
- `app/__init__.py` — `static_folder=None`, Flask больше не раздаёт файлы
- `app/routes.py` — убран маршрут `GET /`
- `static/index.html` — путь к JS изменён с `/static/js/app.js` на `/js/app.js`
- Статические файлы монтируются как volume — изменения без пересборки контейнера

**Проблемы / корректировки:**
- (нет)

**Результаты проверки:**
- Страница загружается на `http://localhost:5000/`
- Таблица отображает 5 seed-пользователей
- Клик по строке открывает модальное окно с деталями
- Два контейнера работают (api + frontend)
- Изменения в `static/` подхватываются без пересборки

---

## Этап 4. Задание 3 — Интеграция

**Что сделано:**
- `app/models.py` — добавлена `create_user(name, email)`, возвращает созданного пользователя
- `app/routes.py` — `POST /users`: парсинг JSON, валидация (имя, email, формат email),
  возврат 201 при успехе, 400 при ошибке
- `static/index.html` — форма добавления (карточка над таблицей), контейнер для алертов
- `static/js/app.js` — `handleAddUser()`: POST через Fetch API, `showAlert()`:
  Bootstrap-алерты с автоскрытием через 5 сек, обновление таблицы без перезагрузки

**Что скорректировано после ревью:**
- (нет)

**Проблемы / корректировки:**
- (нет)

**Результаты проверки:**
- Пустое тело → 400 «Тело запроса должно быть JSON»
- Пустое имя → 400 «Имя обязательно»
- Некорректный email → 400 «Некорректный формат email»
- Успешное создание → 201, пользователь в ответе и в таблице
- HTML-валидация (`required`) не пускает пустую форму на клиенте
- Зелёное уведомление при успехе, автоскрытие через 5 сек
- Таблица обновляется без перезагрузки страницы

---

## Этап 5. Документация

**Что сделано:**
- `README.md` дополнен разделом «Запуск»: требования, команды, описание процесса,
  таблица API-эндпоинтов, управление данными (сброс БД)

**Что скорректировано после ревью:**
- Убрано разделение Docker Engine / Docker Desktop — несущественно для пользователя
- Команды приведены к современному синтаксису `docker compose` (без дефиса)
- Требования упрощены до «Docker с поддержкой Compose»

**Проблемы / корректировки:**
- (нет)

---

## Этап 6. Финальная проверка

**Что сделано:**
- Полный прогон с нуля: удаление БД, пересборка контейнеров
- Проверка всех API-эндпоинтов (GET /users, GET /users/1, GET /users/999, POST /users, POST с невалидными данными)
- Проверка персистентности: перезапуск контейнеров, данные на месте
- Проверка UI: таблица, модалка, форма, уведомления
- Все пункты CHECKLIST.md отмечены как выполненные

**Что скорректировано после ревью:**
- (нет)

**Проблемы / корректировки:**
- (нет)

---

## Этап 7. Планирование тестов

**Что сделано:**
- Определены уровни тестирования: unit (models.py), интеграционные (API), фронтенд (lint/unit/E2E)
- Выбраны инструменты: pytest, pytest-cov, Flask test_client, фикстуры с `:memory:` SQLite
- Составлен чеклист тестов: `CHECKLIST-TESTS.md`
- E2E-тесты решено не реализовывать (overkill для учебного проекта)
- Тесты проектируются CI-ready: одна команда запуска, exit code, отчёт покрытия
- CI-конфиг и badge покрытия — запланированы как отдельный этап

**Почему тесты добавляются после реализации, а не параллельно (TDD):**
- Исходное задание не предполагало тестов — проект учебный, логика минимальна
- Решение добавить тесты возникло при планировании CI/CD — пайплайну нужен
  автоматизированный этап проверки, тесты становятся необходимой инфраструктурой
- Для зрелого проекта это типичная ситуация: тесты дописываются
  к работающему коду при переходе от ручной проверки к автоматизированной

**Решения на этом этапе:**
- `pytest` вместо `unittest` — лаконичнее, стандарт де-факто
- Временная БД в памяти (`:memory:`) — быстро, изолированно, без файлов
- Отдельный `requirements-test.txt` — тестовые зависимости не попадают в production-образ
- Фронтенд-тестирование: ESLint обязательно, Jest опционально

**Проблемы / корректировки:**
- (нет)

---

## Этап 8. Unit-тесты models.py

**Что сделано:**
- `requirements-test.txt` — pytest 9.0.2, pytest-cov 6.1.1, ссылка на requirements.txt
- `tests/__init__.py`, `tests/conftest.py` — фикстура `_tmp_db` (autouse):
  подменяет `DATA_DIR` и `DATABASE` через monkeypatch на `tmp_path`,
  каждый тест получает чистую БД
- `tests/test_models.py` — 13 тестов по 6 классам:
  `TestGetConnection` (2), `TestInitDb` (3), `TestSeedDb` (1),
  `TestGetAllUsers` (3), `TestGetUserById` (2), `TestCreateUser` (2)
- `Dockerfile` — multi-stage build: стадия `base` (production) и `test` (+ pytest)
- `docker-compose.yml` — сервис `test` с профилем `test`, `target: test`;
  сервис `api` явно указывает `target: base`
- Запуск: `docker compose run --rm test`
- `README.md` — раздел «Тесты», обновлена структура проекта и таблица инструментов

**Результаты проверки:**
- 13/13 тестов passed
- Покрытие: `models.py` — 100%, `config.py` — 100%, общее — 69%
- Продакшен-сборка (`docker compose build api`) не затронута

**Что скорректировано после ревью:**
- (нет)

**Проблемы / корректировки:**
- (нет)

---

## Этап 9. Интеграционные тесты API

**Что сделано:**
- `tests/conftest.py` — добавлена фикстура `client`: создаёт Flask-приложение
  через `create_app()`, отдаёт `test_client()` с временной БД
- `tests/test_api.py` — 12 тестов по 4 классам:
  `TestGetUsers` (3), `TestGetUserById` (2), `TestPostUsers` (5),
  `TestPostThenGet` (2 — сценарий «создал → получил»)
- Проверены все эндпоинты: GET /users, GET /users/<id>, POST /users
- Проверена валидация: пустое имя, некорректный email, отсутствие тела, пустой JSON
- CHECKLIST-TESTS.md — отмечены все пункты интеграционных тестов и инфраструктуры

**Результаты проверки:**
- 25/25 тестов passed (13 unit + 12 integration)
- Покрытие: models.py — 100%, routes.py — 97%, __init__.py — 100%, общее — 99%

**Что скорректировано после ревью:**
- (нет)

**Проблемы / корректировки:**
- Первый запуск использовал закешированный образ без новых файлов.
  Решение: явный `docker compose build test` перед `run`

---

## Этап 10. Линтинг фронтенда (ESLint + html-validate)

**Что сделано:**
- `package.json` — ESLint 9, globals, html-validate, скрипты `lint:js`, `lint:html`, `lint`
- `eslint.config.js` — flat config: browser globals, `bootstrap` как readonly, правила `no-undef`, `eqeqeq`
- `.htmlvalidate.json` — `html-validate:recommended`, отключены `no-trailing-whitespace` и `require-sri`
- `Dockerfile.lint` — `node:22-alpine`, установка зависимостей, запуск `npm run lint`
- `docker-compose.yml` — сервис `lint` с профилем `test`
- `.gitignore` — добавлен `node_modules/`
- Запуск: `docker compose run --rm lint`

**Исправления по результатам html-validate:**
- `static/index.html` — добавлен `scope="col"` на три `<th>` (WCAG H63, доступность таблиц)
- `static/index.html` — убран `aria-hidden="true"` с модального окна
  (содержит фокусируемые элементы; Bootstrap управляет этим атрибутом динамически)

**Отклонённые тесты:**
- Jest (unit-тесты JS) — нецелесообразно: функции в `app.js` не содержат
  бизнес-логики, только обращения к DOM и fetch. Для их тестирования потребовалось бы
  мокать fetch, document, bootstrap.Modal — объём подготовки превышает объём тестируемого кода
- E2E — решено ранее (этап 7)

**Результаты проверки:**
- ESLint: 0 ошибок, 0 предупреждений
- html-validate: 0 ошибок, 0 предупреждений

**Проблемы / корректировки:**
- Долгая первичная сборка (скачивание node:22-alpine + npm install). При повторных запусках
  образ кешируется

---

## Этап 11. CI/CD (GitHub Actions)

**Что сделано:**
- `CHECKLIST-CICD.md` — чеклист с планом, секретами, пунктами проверки
- `.github/workflows/ci.yml` — 4 джоба в 3 визуальных фазах:
  - Фаза 1: `test` (pytest + покрытие + badge) и `lint` (ESLint + html-validate) — параллельно
  - Фаза 2: `build` — сборка образа на раннере, `docker save | gzip`, SCP на сервер
  - Фаза 3: `deploy` — SSH: `git pull`, `docker load`, `docker compose up -d`, очистка архива
- Подготовка: создан Gist для badge, PAT, заполнены все секреты в GitHub
- `README.md` — badge CI/CD и покрытия, обновлены структура проекта и таблица документов
- `CHECKLIST-TESTS.md` — отмечены пункты CI-конфиг и badge

**Решения на этом этапе:**
- Сборка на раннере, не на сервере (сервер слабый)
- Доставка образа через SCP (без Docker Registry — проще для одного сервера)
- Образ доставляется на сервер в конце фазы build, а не в фазе deploy —
  чёткое разделение: build = сборка + доставка, deploy = развёртывание
- Обновление кода на сервере через `git pull` (compose, static, nginx.conf)
- Badge через Shields.io + Gist (без внешних сервисов типа Codecov)
- Тесты на PR (без деплоя), полный пайплайн на push в master

**Что скорректировано после ревью:**
- Первая версия ci.yml объединяла сборку и деплой в один джоб — визуально
  отображалось 2 фазы вместо 3. Разделено на отдельные джобы build и deploy

**Подготовительные действия (ручные):**
- Создать Gist с `coverage.json`, получить GIST_ID
- Создать PAT с правом `gist`, добавить как GIST_TOKEN
- Настроить SSH-ключ, добавить секреты SSH_KEY, SSH_HOST, SSH_USER, SSH_PORT, DEPLOY_PATH
- Клонировать репо на сервер в DEPLOY_PATH

**Проблемы / корректировки:**
- (нет)

---

<!-- Шаблон для следующих этапов:

## Этап N. <Название>

**Что сделано:**
- ...

**Что скорректировано после ревью:**
- ...

**Проблемы / корректировки:**
- ...

-->
